import 'dart:math';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter/scheduler.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();
  
  // ØªØ«Ø¨ÙŠØª Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø£ÙÙ‚ÙŠ
  SystemChrome.setPreferredOrientations([
    DeviceOrientation.landscapeLeft,
    DeviceOrientation.landscapeRight,
  ]).then((_) {
    runApp(const JamalyApp());
  });
}

class JamalyApp extends StatelessWidget {
  const JamalyApp({super.key});

  @override
  Widget build(BuildContext context) {
    SystemChrome.setEnabledSystemUIMode(SystemUiMode.immersiveSticky);

    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Jamaly Twist Lick Dunk',
      theme: ThemeData(fontFamily: 'Cairo'),
      home: const GameScreen(),
    );
  }
}

// --- Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ÙˆØ¬ Ø§Ù„ÙÙŠØ²ÙŠØ§Ø¦ÙŠ ---
class MilkSpring {
  double height;
  double targetHeight;
  double velocity = 0;
  final double k = 0.015; 
  final double damp = 0.02; 

  MilkSpring({required this.targetHeight}) : height = targetHeight;

  void update() {
    double x = height - targetHeight;
    double acceleration = -k * x - damp * velocity;
    velocity += acceleration;
    height += velocity;
  }
}

// --- Ø§Ù„Ø£Ù†ÙˆØ§Ø¹ ÙˆØ§Ù„Ø­Ø§Ù„Ø§Øª ---
enum CookieState { FLYING, TWISTED, LICKED, HELD, DROPPING }

class Cookie {
  double x, y, vx, vy, r, angle, rotSpeed;
  CookieState state;
  double twistOffset;
  bool isDead = false;
  double dragOffsetX = 0;
  double dragOffsetY = 0;
  int faceType; 

  Cookie({
    required this.x, required this.y, required this.vx, required this.vy,
    this.r = 65, 
    this.state = CookieState.FLYING,
    this.twistOffset = 0,
    this.angle = 0,
    this.rotSpeed = 0.05,
    required this.faceType,
  });
}

class Particle {
  double x, y, vx, vy, size, life;
  Color color;
  double opacity = 1.0;

  Particle(this.x, this.y, this.vx, this.vy, this.color)
      : size = Random().nextDouble() * 8 + 3, life = 1.0;

  void update() {
    x += vx; y += vy; vy += 0.5; life -= 0.025;
    opacity = life.clamp(0, 1);
  }
}

class FloatingText {
  double x, y, life, scale;
  String text, subText;
  Color color;
  FloatingText(this.x, this.y, this.text, this.subText, {this.color = Colors.red})
      : life = 1.0, scale = 0.5;
}

// --- Ø´Ø§Ø´Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ---
class GameScreen extends StatefulWidget {
  const GameScreen({super.key});

  @override
  State<GameScreen> createState() => _GameScreenState();
}

class _GameScreenState extends State<GameScreen> with SingleTickerProviderStateMixin {
  late Ticker _ticker;
  Size screenSize = Size.zero;
  bool isPlaying = false;
  int score = 0;
  double timeLeft = 60;

  List<Cookie> cookies = [];
  List<Cookie> heldCookies = [];
  List<Particle> particles = [];
  List<FloatingText> texts = [];
  List<MilkSpring> springs = []; 

  double fanAngle = 0;
  Rect glassRect = Rect.zero;
  Offset touchPosition = Offset.zero;

  @override
  void initState() {
    super.initState();
    _ticker = createTicker(_onTick)..start();
    _startGame();
  }

  // Ù…ÙŠØ²Ø© Ø§Ù„ØµÙˆØª: Ø§Ù‡ØªØ²Ø§Ø² ÙˆÙ†ØºÙ…Ø© Ø¨Ø³ÙŠØ·Ø© Ø¹Ù†Ø¯ Dunk
  void _playGameSound(bool isDunk) {
    if (isDunk) {
      HapticFeedback.heavyImpact(); // Ø§Ù‡ØªØ²Ø§Ø² Ù‚ÙˆÙŠ
      SystemSound.play(SystemSoundType.click); // Ù†ØºÙ…Ø© Ù†Ø¸Ø§Ù…
    } else {
      HapticFeedback.lightImpact(); // Ø§Ù‡ØªØ²Ø§Ø² Ø®ÙÙŠÙ Ø¹Ù†Ø¯ Ø§Ù„Ø¥Ù…Ø³Ø§Ùƒ
    }
  }

  void _initSprings(double surfaceY) {
    if (springs.isNotEmpty) return;
    for (int i = 0; i < 60; i++) {
      springs.add(MilkSpring(targetHeight: surfaceY));
    }
  }

  void _startGame() {
    score = 0; timeLeft = 60; isPlaying = true;
    _spawnLoop();
  }

  Future<void> _spawnLoop() async {
    while (isPlaying && mounted) {
      await Future.delayed(const Duration(milliseconds: 1200));
      if (screenSize != Size.zero) _spawnCookie();
    }
  }

  void _spawnCookie() {
    Random rng = Random();
    cookies.add(Cookie(
      x: screenSize.width + 100,
      y: screenSize.height * 0.3 + rng.nextDouble() * screenSize.height * 0.4,
      vx: -(4.0 + rng.nextDouble() * 5.0),
      vy: -(7.0 + rng.nextDouble() * 5.0),
      faceType: rng.nextInt(2),
    ));
  }

  void _onTick(Duration elapsed) {
    if (screenSize == Size.zero) return;

    setState(() {
      if (timeLeft > 0) timeLeft -= 0.016; else isPlaying = false;
      fanAngle += 0.05;

      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…ÙˆØ¬
      for (var s in springs) s.update();
      double spread = 0.18;
      for (int it = 0; it < 4; it++) {
        for (int i = 0; i < springs.length; i++) {
          if (i > 0) {
            double d = spread * (springs[i].height - springs[i - 1].height);
            springs[i - 1].velocity += d; springs[i - 1].height += d;
          }
          if (i < springs.length - 1) {
            double d = spread * (springs[i].height - springs[i + 1].height);
            springs[i + 1].velocity += d; springs[i + 1].height += d;
          }
        }
      }

      // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¨Ø³ÙƒÙˆÙŠØª
      for (var c in cookies) {
        if (c.state != CookieState.HELD) {
          c.vy += 0.35; c.x += c.vx; c.y += c.vy; c.angle += c.rotSpeed;
          if (c.y > springs[0].targetHeight && glassRect.contains(Offset(c.x, c.y)) && !c.isDead) {
            _dunkCookie(c);
          }
        }
        if (c.y > screenSize.height + 150) c.isDead = true;
      }

      for (var c in heldCookies) {
        c.x = ui.lerpDouble(c.x, touchPosition.dx + c.dragOffsetX, 0.2)!;
        c.y = ui.lerpDouble(c.y, touchPosition.dy + c.dragOffsetY, 0.2)!;
        if (c.twistOffset < 22) c.twistOffset += 2;
      }

      cookies.removeWhere((c) => c.isDead);
      for (var p in particles) p.update();
      particles.removeWhere((p) => p.life <= 0);
      for (var t in texts) { t.y -= 1.2; t.life -= 0.02; if (t.scale < 1.4) t.scale += 0.04; }
      texts.removeWhere((t) => t.life <= 0);
    });
  }

  void _dunkCookie(Cookie c) {
    c.isDead = true; score += 250;
    _playGameSound(true);
    int idx = (((c.x - glassRect.left) / glassRect.width) * springs.length).floor().clamp(0, springs.length - 1);
    springs[idx].velocity = 50;
    texts.add(FloatingText(c.x, c.y - 120, "DUNKED!", "+250", color: Colors.blueAccent));

    Random rng = Random();
    for (int i = 0; i < 20; i++) {
      particles.add(Particle(c.x, springs[idx].height, (rng.nextDouble()-0.5)*10, -rng.nextDouble()*15, Colors.white));
    }
  }

  void _onPanUpdate(DragUpdateDetails d) {
    touchPosition = d.localPosition;
    for (int i = cookies.length - 1; i >= 0; i--) {
      var c = cookies[i];
      if ((Offset(c.x, c.y) - touchPosition).distance < 90 && (c.state == CookieState.FLYING || c.state == CookieState.DROPPING)) {
        c.state = CookieState.HELD;
        c.dragOffsetX = c.x - touchPosition.dx; c.dragOffsetY = c.y - touchPosition.dy;
        cookies.removeAt(i); heldCookies.add(c);
        score += 100;
        _playGameSound(false);
        texts.add(FloatingText(c.x, c.y - 80, "GOT IT!", "+100", color: Colors.orange));
        break;
      }
    }
  }

  void _onPanEnd(DragEndDetails d) {
    for (var c in heldCookies) {
      c.state = CookieState.DROPPING;
      c.vx = d.velocity.pixelsPerSecond.dx * 0.001;
      c.vy = d.velocity.pixelsPerSecond.dy * 0.001 + 2;
      cookies.add(c);
    }
    heldCookies.clear();
  }

  @override
  void dispose() { _ticker.dispose(); super.dispose(); }

  @override
  Widget build(BuildContext context) {
    screenSize = MediaQuery.of(context).size;
    if (screenSize != Size.zero) {
      glassRect = Rect.fromLTWH(80, screenSize.height - 300, 200, 280);
      _initSprings(glassRect.top + 80);
    }
    return Scaffold(
      backgroundColor: Colors.black,
      body: GestureDetector(
        onPanUpdate: _onPanUpdate, onPanEnd: _onPanEnd,
        child: Stack(
          children: [
            CustomPaint(painter: GamePainter(cookies: [...cookies, ...heldCookies], particles: particles, texts: texts, springs: springs, fanAngle: fanAngle, glassRect: glassRect), child: Container()),
            Positioned(top: 25, left: 25, child: _buildHud("ğŸª $score", Colors.orange)),
            Positioned(top: 25, right: 25, child: _buildHud("â±ï¸ ${timeLeft.toInt()}", Colors.blue)),
          ],
        ),
      ),
    );
  }

  Widget _buildHud(String text, Color color) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 22, vertical: 12),
      decoration: BoxDecoration(color: Colors.white, borderRadius: BorderRadius.circular(25), border: Border.all(color: color, width: 4)),
      child: Text(text, style: TextStyle(fontSize: 26, fontWeight: FontWeight.bold, color: color)),
    );
  }
}

class GamePainter extends CustomPainter {
  final List<Cookie> cookies;
  final List<Particle> particles;
  final List<FloatingText> texts;
  final List<MilkSpring> springs;
  final double fanAngle;
  final Rect glassRect;

  GamePainter({required this.cookies, required this.particles, required this.texts, required this.springs, required this.fanAngle, required this.glassRect});

  @override
  void paint(Canvas canvas, Size size) {
    // 1. Ø§Ù„Ø®Ù„ÙÙŠØ© ÙˆØ§Ù„Ù…Ø·Ø¨Ø®
    canvas.drawRect(Rect.fromLTWH(0, 0, size.width, size.height), Paint()..color = const Color(0xFF81D4FA));
    
    // Ø§Ù„Ù…Ø±ÙˆØ­Ø©
    canvas.save();
    canvas.translate(size.width * 0.3, 60); canvas.rotate(fanAngle);
    for(int i=0; i<3; i++) {
      canvas.drawRRect(RRect.fromRectAndRadius(const Rect.fromLTWH(-10, -5, 20, 90), const Radius.circular(10)), Paint()..color = Colors.orangeAccent);
      canvas.rotate(2*pi/3);
    }
    canvas.restore();

    // Ø§Ù„Ø±Ø®Ø§Ù…Ø© ÙˆØ§Ù„Ø«Ù„Ø§Ø¬Ø©
    canvas.drawRRect(RRect.fromRectAndRadius(Rect.fromLTWH(size.width - 260, 50, 200, size.height - 150), const Radius.circular(20)), Paint()..color = Colors.white);
    canvas.drawRect(Rect.fromLTWH(0, size.height - 90, size.width, 90), Paint()..color = Colors.brown);

    // 2. Ø§Ù„ÙƒÙˆØ¨ ÙˆØ§Ù„Ù„Ø¨Ù† (Ø§Ù„Ù…ÙˆØ¬)
    canvas.drawRRect(RRect.fromRectAndRadius(glassRect, const Radius.circular(15)), Paint()..color = Colors.white24);
    if (springs.isNotEmpty) {
      Path path = Path();
      path.moveTo(glassRect.left + 5, glassRect.bottom - 5);
      path.lineTo(glassRect.left + 5, springs[0].height);
      for (int i = 0; i < springs.length - 1; i++) {
        double x1 = glassRect.left + 5 + ((glassRect.width - 10) * i / (springs.length - 1));
        double x2 = glassRect.left + 5 + ((glassRect.width - 10) * (i + 1) / (springs.length - 1));
        path.cubicTo((x1+x2)/2, springs[i].height, (x1+x2)/2, springs[i+1].height, x2, springs[i+1].height);
      }
      path.lineTo(glassRect.right - 5, glassRect.bottom - 5); path.close();
      canvas.drawPath(path, Paint()..color = Colors.white);
    }
    canvas.drawRRect(RRect.fromRectAndRadius(glassRect, const Radius.circular(15)), Paint()..color = Colors.white54..style=PaintingStyle.stroke..strokeWidth=3);

    // 3. Ø§Ù„Ø¨Ø³ÙƒÙˆÙŠØª
    for (var c in cookies) {
      canvas.save(); canvas.translate(c.x, c.y);
      if (c.state != CookieState.HELD) {
        canvas.rotate(c.angle);
        _drawCookieCore(canvas, c.r);
      } else {
        canvas.save(); canvas.translate(-c.twistOffset, 0); _drawLayer(canvas, c.r); canvas.restore();
        canvas.save(); canvas.translate(c.twistOffset, 0); _drawLayer(canvas, c.r); canvas.restore();
      }
      canvas.restore();
    }

    // 4. Ø§Ù„Ø¬Ø²ÙŠØ¦Ø§Øª ÙˆØ§Ù„Ù†ØµÙˆØµ
    for (var p in particles) canvas.drawCircle(Offset(p.x, p.y), p.size, Paint()..color = p.color.withOpacity(p.opacity));
    for (var t in texts) {
      TextPainter(text: TextSpan(text: t.text, style: TextStyle(color: t.color, fontSize: 24 * t.scale, fontWeight: FontWeight.bold)), textDirection: TextDirection.ltr)..layout()..paint(canvas, Offset(t.x - 50, t.y));
    }
  }

  void _drawCookieCore(Canvas canvas, double r) {
    _drawLayer(canvas, r, isBottom: true);
    canvas.drawCircle(Offset.zero, r * 0.9, Paint()..color = const Color(0xFFF5F5DC)); // ÙƒØ±ÙŠÙ…Ø©
    _drawLayer(canvas, r);
  }

  void _drawLayer(Canvas canvas, double r, {bool isBottom = false}) {
    canvas.drawCircle(Offset(isBottom ? 2 : 0, isBottom ? 2 : 0), r, Paint()..color = const Color(0xFF3E2723));
    canvas.drawCircle(Offset.zero, r - 8, Paint()..color = Colors.black26..style=PaintingStyle.stroke..strokeWidth=2);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}